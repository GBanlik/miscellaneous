use [AdventureWorks];

-- Utilities: Create udfDropSchema() which drops a schema and all its binding objects
drop procedure if exists udfDropSchema;
go

create procedure udfDropSchema(@Schema nvarchar(200))
as

	declare @Sql nvarchar(max) = '';

	--constraints
	select @Sql = @Sql + 'alter table '+ quotename(@Schema) + '.' + quotename(t.name) + ' drop constraint ' + quotename(f.name)  + ';' + char(13)
	from sys.tables t 
		inner join sys.foreign_keys f on f.parent_object_id = t.object_id 
		inner join sys.schemas s on t.schema_id = s.schema_id
	where s.name = @Schema
	order by t.name;

	--tables
	select @Sql = @Sql + 'drop table '+ quotename(@Schema) +'.' + quotename(TABLE_NAME) + ';' + char(13)
	from INFORMATION_SCHEMA.TABLES
	where TABLE_SCHEMA = @Schema AND TABLE_TYPE = 'BASE TABLE'
	order by TABLE_NAME

	--views
	select @Sql = @Sql + 'drop view '+ quotename(@Schema) +'.' + quotename(TABLE_NAME) + ';' + char(13)
	FROM INFORMATION_SCHEMA.TABLES
	where TABLE_SCHEMA = @Schema AND TABLE_TYPE = 'VIEW'
	order by TABLE_NAME

	--procedures
	select @Sql = @Sql + 'drop procedure '+ quotename(@Schema) +'.' + quotename(ROUTINE_NAME) + ';' + char(13)
	from INFORMATION_SCHEMA.ROUTINES
	where ROUTINE_SCHEMA = @Schema AND ROUTINE_TYPE = 'PROCEDURE'
	order by ROUTINE_NAME

	--functions
	select @Sql = @Sql + 'drop function '+ quotename(@Schema) +'.' + quotename(ROUTINE_NAME) + ';' + char(13)
	from INFORMATION_SCHEMA.ROUTINES
	where ROUTINE_SCHEMA = @Schema AND ROUTINE_TYPE = 'FUNCTION'
	order by ROUTINE_NAME

	--sequences
	select @Sql = @Sql + 'drop sequence '+ quotename(@Schema) +'.' + quotename(SEQUENCE_NAME) + ';' + char(13)
	from INFORMATION_SCHEMA.SEQUENCES
	where SEQUENCE_SCHEMA = @Schema
	order by SEQUENCE_NAME

	select @Sql = @Sql + 'drop schema if exists '+ quotename(@Schema) + ';' + char(13)

	execute sp_executesql @Sql

GO

-- Step 1) Create the new schema

-- Remove all the objects in the schema so we can drop it

exec udfDropSchema 'Auction';
go

create schema Auction authorization dbo;
go
-- Step 2) Create the Auction.Product table

drop table if exists Auction.Product;

create table Auction.Product
(
	AuctionProductID int identity not null,
	ProductID int not null,
	InitialBidPrice money not null,
	ExpireDate datetime not null,
	Deprecated bit not null default 0,
	CreatedAt datetime not null default convert(char(10),getdate(), 23),
	RemovedAt datetime null default null,

	primary key(AuctionProductID),
	foreign key (ProductID) references Production.Product(ProductID),

	-- Add unique constraint: only one active ProductID version at a given time
	--constraint UQ_ProductIDDeprecated unique (ProductID, Deprecated)
)

-- Implement a filtered nonclustered index to act as a unique contraint on (ProductID, Deprecated = 1)
create nonclustered index FI_ProductIDDeprecated on Auction.Product (ProductID, Deprecated) where Deprecated = 1;

create nonclustered index CI_Auction_Products_ProductID on Auction.Product (ProductID);

-- Step 3) Create the Auction.Bid table

drop table if exists Auction.Bid;

create table Auction.Bid
(
	BidID int identity not null,
	AuctionProductID int not null,
	CustomerID int not null,
	BidValue money not null,
	Deprecated bit not null default 0,
	CreatedAt datetime not null default convert(char(10),getdate(), 23),
	RemovedAt datetime null default null,

	primary key (BidID),
	foreign key (AuctionProductID) references Auction.Product(AuctionProductID),
	foreign key (CustomerID) references Sales.Customer(CustomerID)
)

create nonclustered index CI_Auction_Bids_ProductID on Auction.Bid (AuctionProductID);


-- Step X) Create the Auction.Sales table to keep track of our auction sales
-- Note that the header info is still inserted into the orders table, however,
-- this seggregation allows easy backtracking and performance attribution.

drop table if exists Auction.Sale;

create table Auction.Sale
(
	AuctionSaleID int identity not null,
	AuctionProductID int not null,
	CustomerID int not null,
	AuctionBidID int not null,
	SaleValue money not null,
	Deprecated bit not null default 0,
	CreatedAt datetime not null default convert(char(10),getdate(), 23),
	RemovedAt datetime null default null,

	primary key (AuctionSaleID),
	foreign key (AuctionProductID) references Auction.Product (AuctionProductID),
	foreign key (AuctionBidID) references Auction.Bid (BidID),
	foreign key (CustomerID) references Sales.Customer (CustomerID),
	--foreign key (SalesOrderID) references Sales.SalesOrderHeader (SalesOrderID)
)

-- Step 4) Create Action.Error table which contains any error generated by a Throwable

drop table if exists Auction.Error;

create table Auction.Error
(
	ID int identity not null,
	UserName nvarchar(max) not null,
	ErrorID int not null,
	ErrorMessage nvarchar(max) not null,
	CreatedAt datetime not null default convert(char(10),getdate(), 23),

	primary key (ID)
);

-- Step X) Create and populate the thresholds table

drop table if exists Auction.Threshold;

create table Auction.Threshold
(
	ThresholdID int identity not null,
	Value nvarchar(50) not null,
	[Description] nvarchar(max) not null,

	Deprecated bit not null default 0,
	CreatedAt datetime not null default convert(char(10),getdate(), 23),
	RemovedAt datetime null default null,

	primary key (ThresholdID),
);

insert into Auction.Threshold (Value, Description) values ('0.75', 'Auction - Non-manufactured product initial bid multiplier.');
insert into Auction.Threshold (Value, Description) values ('0.5', 'Auction - Manufactured product initial bid multiplier.');
insert into Auction.Threshold (Value, Description) values ('0.05', 'Auction - Minimum bid value.');
insert into Auction.Threshold (Value, Description) values ('1', 'Auction - Maximum bid increment as a multiplier of the ListPrice .');
insert into Auction.Threshold (Value, Description) values ('50', 'Auction - Minimum Product List Price to be eligible for auction.');
insert into Auction.Threshold (Value, Description) values ('20201115', 'Auction - Minimum bid start date.');
insert into Auction.Threshold (Value, Description) values ('20201201', 'Auction - Minimum bid end date.');

go

/*
	*****************************************
	Assignment Procedure Creation Section
	*****************************************
*/

-- Create uspAddProductToAuction

create or alter procedure Auction.uspAddProductToAuction
(
	@ProductID int
	,@ExpireDate datetime = null
	,@InitialBidPrice money = null
)
as

	SET NOCOUNT ON
    SET XACT_ABORT ON

	begin try
	/*
		Assumptions: only one active instance of a given ProductID can exist at a given point in time.
		Meaning, if an instance is active, then it is set to Deprecated and all its bidder's money must be returned thus,
		the bids are deprecated as well.
	*/

		begin transaction SCHEDULED_INSERT

			if @ProductID is null
				throw 50001, 'Auction.uspAddProductToAuction(...) - ProductID has not been supplied', 0;

			if @ProductID not in (select ProductID from Production.Product)
				throw 50001, 'Auction.uspAddProductToAuction(...) - Product is non-existant in Production.Product', 0;

			if @ExpireDate is not null and @ExpireDate < getdate()
				throw 50001, 'Auction.uspAddProductToAuction(...) - Invalid expire date', 0;

			declare 
				@product_min_value as money -- The configurable minimum ListPrice to consider (50USD by default)
				,@product_original_price money -- The product's original ListPrice
				,@product_price money -- The product's modified Auction listing price
				,@product_category int -- The product's category
				,@expire_date datetime; -- The modified expire date
			
			select
				@product_min_value = coalesce(try_cast(Value as float), 50.0)
			from
				Auction.Threshold
			where
				ThresholdID = 5;

			-- Check if the product has not been discontinued
			if not exists (select 1 from Production.Product where ProductID = @ProductID and ListPrice > @product_min_value and (SellEndDate is null and DiscontinuedDate is null))
				throw 50003, 'Auction.uspAddProductToAuction(...) - The product has been discontinued or its list price is bellow 50USD.', 0;

			set @expire_date = @ExpireDate
			set @product_price = null
	
			-- If the supplied bid price is missing then consider 50% of the price's intial value, else 75% if its MakeFlag.
			-- In practice, these values are defined in the Auction.Threshold table, under IDs 1 and 2.
			select 
				@product_price = p1.ListPrice * 
					(select try_cast(t1.[value] as float) from Auction.Threshold t1 where t1.ThresholdID = iif(p1.MakeFlag = 1, 2, 1)),
				@product_original_price = p1.ListPrice,
				@product_category = ps1.ProductCategoryID
			from
				Production.Product p1
			left join
				Production.ProductSubcategory ps1
			on
				p1.ProductSubcategoryID = ps1.ProductSubcategoryID
			where
				p1.ProductID = @ProductID;

			if @product_category = 4
				throw 50002, 'Auction.uspAddProductToAuction(...) - Cannot put acessories up for auction.', 0;

			-- Make sure there is at least one unit of the produce in stock
			if not exists (
				-- Recall that Inventory can have multiple occurences of the same product
				-- corresponding to stock in different locations.
				select 
					sum(Quantity) quantity
				from 
					Production.ProductInventory 
				where 
					ProductID = @ProductID
				having
					sum(Quantity) > 0
				)
				throw 50004, 'Auction.uspAddProductToAuction(...) - There are no available units of the product.', 0;

			-- Ensure a threshold has been found and the threshold value computed
			if @product_price is null
				throw 50002, 'Auction.uspAddProductToAuction(...) - Could not retrieve the lower bound threshold value.', 0;

			-- If the provided price is larger than the minimum (defined by the thresholdMultiplier * ListPrice) use the former
			if @InitialBidPrice > @product_price and @InitialBidPrice <= @product_original_price
				set @product_price = @InitialBidPrice;
			else if @InitialBidPrice < @product_price 
				print('Auction.uspAddProductToAuction(...) - Altering the InitialPricePrice to the minimum value');

			-- Round the initial price (given by @product_price) to 2 decimals, given money makes no sense with more than two decimals
			set @product_price = round(@product_price, 2)

			-- If no expiration date has been provided fix it 7 days from now
			if @expire_date is null 
				set @expire_date = dateadd(D, 7, getdate());

			-- Update all the cases where the Bid is associated with the Product given only one itemID can be at auction at any given time
			update Auction.Bid set Deprecated = 1, RemovedAt = getdate() where AuctionProductID = (select AuctionProductID from Auction.Product where ProductID = @ProductID and Deprecated = 0) and Deprecated = 0;
			-- Update all cases where the product has been listed to deprecate them as only one itemID can be at auction at any given time
			update Auction.Product set Deprecated = 1, RemovedAt = getdate() where ProductID = @ProductID;


			-- Finally insert the Product up for auction
			insert into Auction.Product(ProductID, InitialBidPrice, ExpireDate) values (@ProductID, @product_price, @expire_date);

		commit transaction SCHEDULED_INSERT
		
		return select scope_identity() as AuctionProductID;

	end try
	begin catch
		
		if (@@TRANCOUNT > 0)
		begin
			rollback transaction SCHEDULED_INSERT
		end

		print(concat('User: ', SUSER_SNAME(), '; Error #: ', ERROR_NUMBER(), '; Message: ', ERROR_MESSAGE(), '; Date: ', GETDATE()))

		INSERT INTO Auction.Error (UserName, ErrorID, ErrorMessage, CreatedAt)
			VALUES
		(SUSER_SNAME(),
			ERROR_NUMBER(),
			ERROR_MESSAGE(),
			GETDATE()
		);

		return 1;
	end catch

go

-- Create procedure uspTryBidProduct

create or alter procedure Auction.uspTryBidProduct 
(
	@ProductID int,
	@CustomerID int,
	@BidAmmount money
)
as
    SET NOCOUNT ON
    SET XACT_ABORT ON

	begin try
		begin transaction SCHEDULED_INSERT

		declare 
			@active_auction_prodictid as int
			-- The initial auction price as defined by Auction.Product
			,@auction_initial_price as money
			-- 
			,@minimum_bid as money
			-- 
			,@maximum_bid as money
			-- Current Auction cumulative bid value
			,@bid_running_sum as money
			-- The product's current list price
			,@product_list_price as money
			-- The applicable currency rate
			,@currency_rate as float
			-- The auction termination date as defined by the Admin
			,@auction_end_date as datetime
			-- The bid's time = Procedure execution timestamp
			,@bid_time as datetime
			-- The auction minimum start date as defined in the thresholds
			,@min_start_date datetime
			-- The auction minimum end date as defined in the thresholds
			,@max_end_date datetime;

		set @bid_time = getdate();

		-- Validate input @ProductID
		if @ProductID is null
			throw 50001, 'Auction.uspTryBidProduct(...) - ProductID has not been supplied', 0;

		if @ProductID not in (select ProductID from Production.Product)
			throw 50001,'Auction.uspTryBidProduct(...) - Product is non-existant in Production.Product', 0;

		-- Validate input @CustomerID
		if @CustomerID is null
			throw 50001, 'Auction.uspTryBidProduct(...) - CustomerID has not been supplied', 0;

		if @CustomerID not in (select CustomerID from Sales.Customer)
			throw 50002, 'Auction.uspTryBidProduct(...) - CustomerID is non-existant in Sales.Customer', 0;

		-- Retrieve the active AuctionProductID so we can associate the bid with it
		-- This model allows for multiple sales per product type
		--set @active_auction_prodictid = (select AuctionProductID from Auction.Product where ProductID = @ProductID and Deprecated = 0)
		select
			@active_auction_prodictid = AuctionProductID
			,@auction_end_date = ExpireDate
			,@auction_initial_price = InitialBidPrice
		from 
			Auction.Product 
		where 
			ProductID = @ProductID 
			and 
			Deprecated = 0;

		if @active_auction_prodictid is null
			throw 50002, 'Auction.uspTryBidProduct(...) - No active auction found for the specified product.', 0;

		-- Validate the auction dates
		if @bid_time > @auction_end_date
			throw 50002, 'Auction.uspTryBidProduct(...) - Auction is no longer open', 0;

		-- Fetch the ListPrice so we can truncate the bid amount
		set @product_list_price = (select ListPrice from Production.Product where ProductID = @ProductID);

		-- Compute the bid cumulative sum
		set @bid_running_sum = (select sum(BidValue) running_sum from Auction.Bid where AuctionProductID = @active_auction_prodictid);

		-- Convert the BidAmount to USD
			-- Method returns more values given PersonID may be null
			-- and performs better. However,
		set @currency_rate = 
			(	select
					EndOfDayRate
				from
				(
					select 
							c1.CustomerID
							,cr3.FromCurrencyCode
							,cr3.ToCurrencyCode
							,cr1.EndOfDayRate
							,cr3.last_date
							,row_number() over (partition by c1.CustomerID order by cr3.last_date desc) rn
						from 
							Sales.Customer c1
						inner join
							Sales.SalesTerritory st1
						on
							c1.TerritoryID = st1.TerritoryID
						inner join
							Sales.CountryRegionCurrency crc1
						on
							st1.CountryRegionCode = crc1.CountryRegionCode
						inner join
							Sales.CurrencyRate cr1
						on
							crc1.CurrencyCode = cr1.ToCurrencyCode
							and
							cr1.FromCurrencyCode = 'USD'
						inner join
						(
							select
								cr2.FromCurrencyCode
								,cr2.ToCurrencyCode
								,max(cr2.CurrencyRateDate) last_date
							from
								Sales.CurrencyRate cr2
							group by
								cr2.FromCurrencyCode
								,cr2.ToCurrencyCode
						) cr3
						on
							cr1.FromCurrencyCode = cr3.FromCurrencyCode
							and
							cr1.ToCurrencyCode = cr3.ToCurrencyCode
							and
							cr1.CurrencyRateDate = cr3.last_date
						where
							c1.CustomerID = @CustomerID
					) base
					where
						base.rn = 1
			);

		/*
		-- More complete version, however, Sales.Customer.PersonID is optional
		select
			*
		from
			Sales.Customer c1
		inner join
			Person.Person p1
		on
			c1.PersonID = p1.BusinessEntityID
		inner join
			Person.BusinessEntityAddress bea1
		on
			bea1.BusinessEntityID = p1.BusinessEntityID
		inner join
			Person.Address a1
		on
			bea1.AddressID = a1.AddressID
		inner join
			Person.StateProvince sp1
		on
			a1.StateProvinceID = sp1.StateProvinceID
		inner join
			Person.CountryRegion cr1
		on
			sp1.CountryRegionCode = cr1.CountryRegionCode
		inner join
			Sales.CountryRegionCurrency crc1
		on
			crc1.CountryRegionCode = cr1.CountryRegionCode
		inner join
			Sales.Currency cu1
		on
			crc1.CurrencyCode = cu1.CurrencyCode
		inner join
			Sales.CurrencyRate cra1
		on
			cu1.CurrencyCode = cra1.ToCurrencyCode
		inner join
		(
			select
				cra2.FromCurrencyCode
				,cra2.ToCurrencyCode
				,max(cra2.ModifiedDate) last_date
			from
				Sales.CurrencyRate cra2
			group by
				cra2.FromCurrencyCode
				,cra2.ToCurrencyCode
		) cra3
		on
			cra1.FromCurrencyCode = cra3.FromCurrencyCode
			and
			cra1.ToCurrencyCode = cra3.ToCurrencyCode
			and
			cra1.ModifiedDate = cra3.last_date
		*/


		-- Check the bid value and adjust accordingly
		select @minimum_bid = isnull(try_cast(t1.Value as float), 0.05) from Auction.Threshold t1 where t1.ThresholdID = 3;
		select @maximum_bid = isnull(try_cast(t1.Value as float), 1) from Auction.Threshold t1 where t1.ThresholdID = 4;
		
		-- Check the thresholds to see if the auction is within the specified Threshold limits
		select @min_start_date = isnull(try_cast(t1.Value as datetime),'20201115')  from Auction.Threshold t1 where t1.ThresholdID = 6;
		select @max_end_date = isnull(try_cast(t1.Value as datetime),'20201201')  from Auction.Threshold t1 where t1.ThresholdID = 7;
			
		if not @bid_time between @min_start_date and @max_end_date
			throw 50002, 'Auction.uspTryBidProduct(...) - Auction is not active according to Thresholds.', 0;

		-- Initial bid price * Threshold Multiplier
		set @maximum_bid = @maximum_bid * @product_list_price;

		-- Modify the BidAmount to reflect the currency rate
		set @BidAmmount = @BidAmmount / isnull(@currency_rate, 1.0)

		if isnull(@BidAmmount, -1.0) < @minimum_bid
			set @BidAmmount = iif(@minimum_bid < @maximum_bid, @minimum_bid, @maximum_bid)

		if @auction_initial_price + @bid_running_sum + @BidAmmount > @product_list_price
		begin
			set @BidAmmount = @product_list_price - (@bid_running_sum + @auction_initial_price)
			-- If the correcion makes the bid amount to be smaller than the threshold, then don't accept it
			-- the auction will accept no more bids.
			if @BidAmmount < @minimum_bid
				throw 50005, 'Auction.uspTryAddBidProduct(...) - Maximum value has been achieved', 0;
		end

		-- Round the BidAmount to 2 decimal places
		set @BidAmmount = round(@BidAmmount, 2)

		insert into Auction.Bid (AuctionProductID, CustomerID, BidValue, CreatedAt) values (@active_auction_prodictid, @CustomerID, @BidAmmount, @bid_time);

		commit transaction SCHEDULED_INSERT
	end try
	begin catch

		if (@@TRANCOUNT > 0)
		begin
			rollback transaction SCHEDULED_INSERT
		end

		print(concat('User: ', SUSER_SNAME(), '; Error #: ', ERROR_NUMBER(), '; Message: ', ERROR_MESSAGE(), '; Date: ', GETDATE()))

		INSERT INTO Auction.Error (UserName, ErrorID, ErrorMessage, CreatedAt)
			VALUES
		(SUSER_SNAME(),
			ERROR_NUMBER(),
			ERROR_MESSAGE(),
			GETDATE()
		);

		return 0;

	end catch

	return select scope_identity() as AuctionBidID;

go

-- Create procedure uspRemoveProductFromAuction

create or alter procedure Auction.uspRemoveProductFromAuction
(
	@ProductID int
)
as
	SET NOCOUNT ON
    SET XACT_ABORT ON

	begin try

		begin transaction SCHEDULED_INSERT

		if @ProductID is null
			throw 50001, 'Auction.uspRemoveProductFromAuction(...) - ProductID has not been supplied', 0;

		-- This is unecessary since update will only be performed should the ProductID exist in Auction.Product, but to keep consistency, validate it.
		if @ProductID not in (select ProductID from Auction.Product where Deprecated = 0)
			throw 50001, 'Auction.uspRemoveProductFromAuction(...) - ProductID is not in auction', 0;

		-- Deprecate all the bids associated with this AuctionProductID
		update Auction.Bid set Deprecated = 1, RemovedAt = getdate() where AuctionProductID = (select AuctionProductID from Auction.Product where ProductID = @ProductID and Deprecated = 0) and Deprecated = 0;
		-- Finally deprecate the actual product
		update Auction.Product set Deprecated = 1, RemovedAt = getdate() where ProductID = @ProductID and Deprecated = 0;

		commit transaction SCHEDULED_INSERT
	end try
	begin catch

		if (@@TRANCOUNT > 0)
		begin
			rollback transaction SCHEDULED_INSERT
		end

		print(concat('User: ', SUSER_SNAME(), '; Error #: ', ERROR_NUMBER(), '; Message: ', ERROR_MESSAGE(), '; Date: ', GETDATE()))

		INSERT INTO Auction.Error (UserName, ErrorID, ErrorMessage, CreatedAt)
			VALUES
		(SUSER_SNAME(),
			ERROR_NUMBER(),
			ERROR_MESSAGE(),
			GETDATE()
		);
		
		return 0

	end catch

	return 1
go


-- Create procedure uspSearchForAuctionBasedOnProductName

create or alter procedure Auction.uspSearchForAuctionBasedOnProductName 
(
	@Productname nvarchar(50),
	@StartingOffSet int = 0,
	@NumberOfRows int = 50
)
as
	SET NOCOUNT ON
    SET XACT_ABORT ON

	if @Productname is null
	begin
		print('uspSearchForAuctionBasedOnProductName() supplied ProductName is null.');

		insert into Auction.Error (UserName, ErrorID, ErrorMessage) 
			values (SUSER_SNAME(), 50001, 'uspSearchForAuctionBasedOnProductName() supplied ProductName is null.')
		return 0
	end

	if @StartingOffSet < 0 or @StartingOffSet is null
	begin
		print('uspSearchForAuctionBasedOnProductName() Invalid starting offset.');

		insert into Auction.Error (UserName, ErrorID, ErrorMessage) 
			values (SUSER_SNAME(), 50001, 'uspSearchForAuctionBasedOnProductName() Invalid starting offset.')
		return 0
	end

	if @NumberOfRows < 1 or @NumberOfRows is null
	begin
		print('uspSearchForAuctionBasedOnProductName() Invalid number of rows.');

		insert into Auction.Error (UserName, ErrorID, ErrorMessage) 
			values (SUSER_SNAME(), 50001, 'uspSearchForAuctionBasedOnProductName() Invalid number of rows.')
		return 0
	end

	if len(@ProductName) < 3
	begin
		print('uspSearchForAuctionBasedOnProductName() @ProductName must contain at least 3 characters.');

		insert into Auction.Error (UserName, ErrorID, ErrorMessage)
			values (SUSER_SNAME(), 50003, 'uspSearchForAuctionBasedOnProductName() @ProductName must contain at least 3 characters.')
		return 0
	end

	select
		pp1.Name
		,pp1.ProductNumber
		,pp1.Color
		,pp1.SizeUnitMeasureCode
		,pp1.WeightUnitMeasureCode
		,pp1.Weight
		,pp1.Style
		,pp1.ProductSubcategoryID
		,pp1.ProductModelID
		,last_bid1.BidValue LastBidValue
		,(
			select
				count(ap2.AuctionProductID) product_num
			from
				Auction.Product ap2
			left join
				Production.Product pp2
			on
				ap2.ProductID = pp2.ProductID
			where
				ap2.Deprecated = 0
				and
				ap2.ExpireDate > getdate()
				and
				pp2.Name like '%' + @ProductName + '%'
		) ProductCount
	from
		Auction.Product ap1
	left join
		Production.Product pp1
	on
		ap1.ProductID = pp1.ProductID
	left join
	(
		select
			b1.AuctionProductID
			,b1.BidValue
			-- Remove duplicates in the unlikely event of EXACTLY equal Bid insertion times
			,row_number() over (partition by AuctionProductID order by b1.BidID desc) rn
		from
			Auction.Bid b1
		where
			b1.CreatedAt = (select max(b2.CreatedAt) from Auction.Bid b2 where b2.AuctionProductID = b1.AuctionProductID and b2.Deprecated = 0)
			and
			b1.Deprecated = 0
	) last_bid1
	on
		last_bid1.AuctionProductID = ap1.AuctionProductID
	where
		ap1.Deprecated = 0
		and
		ap1.ExpireDate > getdate()
		and
		pp1.Name like '%' + @ProductName + '%'
		and
		-- Duplicate Removal
		(
			last_bid1.rn is null
			or
			last_bid1.rn = 1
		)
	order by
		pp1.Name
	offset @StartingOffset rows
	fetch next @NumberOfRows rows only;

go

create or alter procedure Auction.uspListBidsOffersHistory 
(
	@CustomerID int,
	@StartTime datetime,
	@EndTime datetime,
	@Active bit = 1
)
as
	SET NOCOUNT ON
    SET XACT_ABORT ON

	if @CustomerID is null
	begin
		print('uspListBidsOffersHistory() supplied CustomerID is null.')
		insert into Auction.Error (UserName, ErrorID, ErrorMessage)
			values (SUSER_SNAME(), 50001, 'uspListBidsOffersHistory() supplied CustomerID is null.');

		return
	end

	if @StartTime is null or @EndTime is null
	begin
		print('uspListBidsOffersHistory() supplied [StartTime, EndTime] is null.')
		insert into Auction.Error (UserName, ErrorID, ErrorMessage)
			values (SUSER_SNAME(), 50001, 'uspListBidsOffersHistory() supplied [StartTime, EndTime] is null.');

		return
	end

	if @StartTime > getdate()
	begin
		print('uspListBidsOffersHistory() supplied @StartTime is invalid.')
		insert into Auction.Error (UserName, ErrorID, ErrorMessage)
			values (SUSER_SNAME(), 50001, 'uspListBidsOffersHistory() supplied @StartTime is invalid.');

		return
	end

	if @StartTime > @EndTime
	begin
		print('uspListBidsOffersHistory() supplied @StartTime is invalid.')
		insert into Auction.Error (UserName, ErrorID, ErrorMessage)
			values (SUSER_SNAME(), 50001, 'uspListBidsOffersHistory() supplied @StartTime is greater than @EndTime.');

		return
	end
	
	select
		ab1.BidID
		,ap1.ProductID
		,p1.[Name] ProductName
		,ab1.BidValue
		,ab1.CreatedAt
		,iif(as1.AuctionProductID is null, 0, 1) ProductPurchased
	from
		Auction.Bid ab1
	left join
		Auction.Product ap1
	on
		ab1.AuctionProductID = ap1.AuctionProductID
	left join
		Auction.Sale as1
	on
		ap1.AuctionProductID = as1.AuctionProductID
		and
		as1.CustomerID = @CustomerID
	left join
		Production.Product p1
	on
		ap1.ProductID = p1.ProductID
	where
		ab1.Deprecated in (0, iif(@Active = 1, 0, 1))
		and
		ab1.CustomerID = @CustomerID
		and
		ab1.CreatedAt between @StartTime and @EndTime
		and
		(
			as1.Deprecated is null
			or
			as1.Deprecated = 0
		);

go

create or alter procedure Auction.uspUpdateProductAuctionStatus
as
	/*
		The function is responsible for updating the status of all the active products.

		For this matter, it performs the following steps:
		1- Retrieve cases of open Auctions under Auction.Product
		2- If the ExpireDate is due, update the Auction.Product status, else stop.
		3- Retrieve the last bid, turning it into the "winning" bid in Auction.Sales
		4- Deprecate all bids for the product, as they are now "deceased".
		5- Finally, consume a product from the inventory. (REMOVED)
	*/

	begin try
		begin transaction UPDATE_STATUS;
		
		-- CTEs work on a one-statement scope, since we need to use these multiple times
		-- and tmp tables are not available in procedures, use a table variable instead
		declare @sales_data table
		(
			AuctionProductID int not null,
			ProductID int not null,
			BidID int null,
			CustomerID int null,
			SaleValue money null
		);
		
		insert into @sales_data
		select
			b3.AuctionProductID
			,b3.ProductID
			,b2.BidID
			,b2.CustomerID
			,sale_info.sale_value
		from
		(
			-- Retrieve the last BidID for active AuctionProductID
			select
				p1.AuctionProductID
				,p1.ProductID
				-- This is sometimes not the best approach, CreatedAt should be used instead
				-- however, we'll use it since the impact should not be felt in this application.
				,max(b1.BidID) last_bid_id
			from
				Auction.Product p1
			left join 
				Auction.Bid b1
			on
				b1.AuctionProductID = p1.AuctionProductID
			where
				-- We need to catch cases where the Product has no bids to be able to close it
				(
					b1.Deprecated = 0
					or
					b1.BidID is null
				)
				and
				p1.Deprecated = 0
				and
				p1.ExpireDate < getdate()
			group by
				p1.AuctionProductID
				,p1.ProductID
		) b3
		left join
			Auction.Bid b2
		on
			b2.AuctionProductID = b3.AuctionProductID
			and
			b2.BidID = b3.last_bid_id
		left join
		(
			select
				bids_total.AuctionProductID
				,bids_total.ProductID
				,(bids_total.cum_value + bids_total.InitialBidPrice /*(select ListPrice from Production.Product where ProductID = bids_total.ProductID)*/) sale_value
			from
			(
				select 
					b4.AuctionProductID
					,p4.ProductID
					,p4.InitialBidPrice
					,sum(b4.BidValue) cum_value
				from 
					Auction.Bid b4 
				left join
					Auction.Product p4
				on
					b4.AuctionProductID = p4.AuctionProductID
				where 
					b4.Deprecated = 0
				group by
					b4.AuctionProductID
					,p4.ProductID
					,p4.InitialBidPrice
			) bids_total
		) sale_info
		on
			sale_info.AuctionProductID = b2.AuctionProductID;

		declare @inventory_stock table
		(
			ProductID int not null,
			LocationID int not null,
			AvailableUnits int not null
		);

		insert into @inventory_stock 
		select
				units1.ProductID
				,units1.LocationID
				,units1.Quantity AvailableUnits
			from
			(
				select
					pi1.ProductID
					,pi1.LocationID
					,pi1.Quantity
					,row_number() over (partition by pi1.ProductID order by pi1.Quantity DESC) rn
				from
					Production.ProductInventory pi1
				where
					pi1.ProductID in (select sd1.ProductID from @sales_data sd1)
					and
					pi1.Quantity > 0
			) units1
			where
				units1.rn = 1;

		-- Removed since we are not supposed to change AdventureWorks
		/*
		-- Consume one unit of each ProductID where the stock is the highest, should it exist
		update Production.ProductInventory 
		set Quantity = Quantity -1
		from
			Production.ProductInventory pi1
		inner join
			@inventory_stock is1 
		on
			pi1.ProductID = is1.ProductID
			and
			pi1.LocationID = is1.LocationID;
		*/

		-- Update the Auction.Sales table inserting the winning Bid to the product sale, should the former exist
		insert into Auction.Sale (AuctionProductID, AuctionBidID, CustomerID, SaleValue) 
			select
				AuctionProductID, 
				BidID, 
				CustomerID, 
				SaleValue
			from
				@sales_data sd1
			inner join
				@inventory_stock is1
			on
				sd1.ProductID = is1.ProductID
			where
				sd1.BidID is not null;

		-- Update the Auction.Product setting the product as deprecated given the unit has been sold
		update Auction.Product 
			set
				Deprecated = 1,
				RemovedAt = getdate()
			where AuctionProductID in 
			(
				select
					AuctionProductID
				from
					@sales_data sd1
			)
			and
			Deprecated = 0;

		-- Update the bids table deprecating all bids associated with the sale
		update Auction.Bid
			set Deprecated = 1,
			RemovedAt = getdate()
		where
			AuctionProductID in (select AuctionProductID from Auction.Sale)
			and 
			Deprecated = 0;

		commit transaction UPDATE_STATUS;

	end try
	begin catch

		if (@@TRANCOUNT > 0)
		begin
			rollback transaction UPDATE_STATUS;
		end

		print(concat('User: ', SUSER_SNAME(), '; Error #: ', ERROR_NUMBER(), '; Message: ', ERROR_MESSAGE(), '; Date: ', GETDATE()))

		INSERT INTO Auction.Error (UserName, ErrorID, ErrorMessage, CreatedAt)
			VALUES
			(
				SUSER_SNAME(),
				ERROR_NUMBER(),
				ERROR_MESSAGE(),
				GETDATE()
			);
		
		return 0
	end catch

